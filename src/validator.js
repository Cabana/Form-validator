// Generated by CoffeeScript 1.6.2
(function() {
  var toSentence,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  toSentence = function(array) {
    var lastWordConnector, sentence, twoWordsConnector, wordsConnector;

    wordsConnector = ", ";
    twoWordsConnector = " and ";
    lastWordConnector = ", and ";
    sentence = void 0;
    switch (array.length) {
      case 0:
        sentence = "";
        break;
      case 1:
        sentence = array[0];
        break;
      case 2:
        sentence = array[0] + twoWordsConnector + array[1];
        break;
      default:
        sentence = array.slice(0, -1).join(wordsConnector) + lastWordConnector + array[array.length - 1];
    }
    return sentence;
  };

  this.FormValidator = (function() {
    function FormValidator() {
      var key, regexes, _i, _len, _ref;

      regexes = {};
      _ref = Object.keys(this.validations);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        regexes[key] = this.validations[key].regex;
      }
      this.parser = new Parser(regexes);
    }

    FormValidator.prototype.validations = {
      email: {
        regex: '.+@.+\\..+',
        errorMessage: 'Email is invalid'
      },
      tel: {
        regex: '\\d{8}',
        errorMessage: 'Telephone number is invalid'
      },
      required: {
        regex: '.+',
        errorMessage: 'Can\'t be blank'
      }
    };

    FormValidator.prototype.validateInput = function(input) {
      var errorMessages, format, isValid, length, validationObject, validationResult, value, wordCount, _i, _ref, _ref1, _ref2, _results,
        _this = this;

      value = input.value;
      validationObject = this._generateValidationObject(input.dataset.validation);
      format = validationObject.format || {};
      length = validationObject.length || {};
      wordCount = validationObject.wordCount || {};
      errorMessages = [];
      isValid = [];
      Object.keys(format).forEach(function(key) {
        var regex, validationResult;

        regex = new RegExp(format[key]);
        validationResult = regex.test(value);
        if (validationResult === false) {
          errorMessages.push(_this.validations[key].errorMessage);
        }
        return isValid.push(validationResult);
      });
      if (length.max && length.min) {
        validationResult = (_ref = value.length, __indexOf.call((function() {
          _results = [];
          for (var _i = _ref1 = length.min, _ref2 = length.max; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; _ref1 <= _ref2 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this), _ref) >= 0);
        if (validationResult === false) {
          errorMessages.push("Value most be at least " + length.min + " and maximum " + length.max + " characters long");
        }
        isValid.push(validationResult);
      } else if (length.min) {
        validationResult = value.length >= length.min;
        if (validationResult === false) {
          errorMessages.push("Value most be at least " + length.min);
        }
        isValid.push(validationResult);
      } else if (length.max) {
        validationResult = value.length <= length.max;
        if (validationResult === false) {
          errorMessages.push("Value can't be longer than " + length.max);
        }
        isValid.push(validationResult);
      }
      Object.keys(wordCount).forEach(function(key) {
        var max, min, regex, _j, _ref3, _results1;

        min = wordCount.min;
        max = wordCount.max;
        regex = /[ ]+/;
        if (min && max) {
          return isValid.push((_ref3 = value.split(regex).length, __indexOf.call((function() {
            _results1 = [];
            for (var _j = min; min <= max ? _j <= max : _j >= max; min <= max ? _j++ : _j--){ _results1.push(_j); }
            return _results1;
          }).apply(this), _ref3) >= 0));
        } else if (min) {
          return isValid.push(value.split(regex).length >= min);
        } else if (max) {
          return isValid.push(value.split(regex).length <= max);
        }
      });
      if (value === '' && validationObject.allowEmpty) {
        isValid = [true];
      }
      this._setErrorMessage(input, errorMessages);
      if (__indexOf.call(isValid, false) >= 0) {
        return false;
      } else {
        return true;
      }
    };

    FormValidator.prototype.defineCustomValidation = function(name, regex, errorMessage) {
      this.validations[name] = {};
      this.validations[name].regex = regex;
      this.validations[name].errorMessage = errorMessage;
      return this.parser.addDefaultValue(name, regex);
    };

    FormValidator.prototype.validateForm = function(form) {
      var input, validationResults, _i, _len, _ref;

      validationResults = [];
      _ref = form.querySelectorAll('input[data-validation], textarea[data-validation]');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        input = _ref[_i];
        validationResults.push(this.validateInput(input));
      }
      if (__indexOf.call(validationResults, false) >= 0) {
        return false;
      } else {
        return true;
      }
    };

    FormValidator.prototype._setErrorMessage = function(input, messages) {
      return input.setAttribute('data-error-message', toSentence(messages).toLowerCase().capitalize());
    };

    FormValidator.prototype._generateValidationObject = function(string) {
      return this.parser.parse(string);
    };

    return FormValidator;

  })();

}).call(this);
