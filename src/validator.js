// Generated by CoffeeScript 1.6.2
(function() {
  var Errors, ValidatableInput, toSentence,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  toSentence = function(array) {
    var lastWordConnector, sentence, twoWordsConnector, wordsConnector;

    wordsConnector = ", ";
    twoWordsConnector = " and ";
    lastWordConnector = ", and ";
    sentence = void 0;
    switch (array.length) {
      case 0:
        sentence = "";
        break;
      case 1:
        sentence = array[0];
        break;
      case 2:
        sentence = array[0] + twoWordsConnector + array[1];
        break;
      default:
        sentence = array.slice(0, -1).join(wordsConnector) + lastWordConnector + array[array.length - 1];
    }
    return sentence;
  };

  Errors = (function() {
    function Errors() {
      this.errors = [];
    }

    Errors.prototype.add = function(message) {
      return this.errors.push(message);
    };

    Errors.prototype.none = function() {
      if (this.errors.length === 0) {
        return true;
      } else {
        return false;
      }
    };

    Errors.prototype.alwaysReturn = function(boolean) {
      return this.none = function() {
        return boolean;
      };
    };

    Errors.prototype.fullMessages = function() {
      return toSentence(this.errors).toLowerCase().capitalize();
    };

    return Errors;

  })();

  ValidatableInput = (function() {
    function ValidatableInput(input) {
      this.input = input;
    }

    ValidatableInput.prototype.setupErrorMessage = function(fullMessages) {
      return this.input.setAttribute('data-error-message', fullMessages);
    };

    ValidatableInput.prototype.resetErrorMessages = function() {
      return this.input.removeAttribute('data-error-message');
    };

    ValidatableInput.prototype.validations = function() {
      return this.input.dataset.validation;
    };

    ValidatableInput.prototype.asHtmlNode = function() {
      return this.input;
    };

    return ValidatableInput;

  })();

  this.FormValidator = (function() {
    function FormValidator() {
      var parser;

      parser = new Parser;
      parser.addDefaultValue('required', true);
      parser.addDefaultValue('allowEmpty', true);
      this.parser = parser;
      this._setupBuiltInValidations();
    }

    FormValidator.prototype.defineValidation = function(name, validatorFunction, errorMessage) {
      return this._validations[name] = {
        validationHandler: validatorFunction,
        errorMessage: errorMessage
      };
    };

    FormValidator.prototype.validateInput = function(inputNode) {
      var input, validations;

      input = new ValidatableInput(inputNode);
      validations = this._generateValidations(input.validations());
      this.errors = new Errors;
      this._performBuiltinValidations(input.asHtmlNode(), validations);
      this._performFormatValidation(input.asHtmlNode(), validations.format);
      input.resetErrorMessages(input);
      if (this.errors.none()) {
        return true;
      } else {
        input.setupErrorMessage(this.errors.fullMessages());
        return false;
      }
    };

    FormValidator.prototype._validations = {};

    FormValidator.prototype._performFormatValidation = function(input, format) {
      var key, _i, _len, _ref, _results;

      if (format) {
        _ref = Object.keys(format);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          key = _ref[_i];
          if (!this._validations[key].validationHandler.test(input.value)) {
            _results.push(this.errors.add(this._validations[key].errorMessage));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }
    };

    FormValidator.prototype._performBuiltinValidations = function(input, validations) {
      var key, _i, _len, _ref, _results;

      _ref = Object.keys(validations);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        if (key !== 'format') {
          _results.push(this._validations[key].validationHandler(input, validations));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    FormValidator.prototype._setupBuiltInValidations = function() {
      var _this = this;

      this.defineValidation('email', /.+@.+\..+/, 'Email is invalid');
      this.defineValidation('tel', /\d{8}/, 'Telephone number is invalid');
      this.defineValidation('number', /^\d+$/, 'Invalid');
      this.defineValidation('required', function(input, data) {
        if (!/^.+$/.test(input.value)) {
          return _this.errors.add("Can't be blank");
        }
      });
      this.defineValidation('length', function(input, data) {
        return _this._performRangeValidation(input.value.length, data.length.min, data.length.max);
      });
      this.defineValidation('wordCount', function(input, data) {
        var length;

        length = input.value === '' ? length = 0 : input.value.split(/[ ]+/).length;
        return _this._performRangeValidation(length, data.wordCount.min, data.wordCount.max);
      });
      this.defineValidation('allowEmpty', function(input, data) {
        return _this._alwaysValidIf(input.value === '');
      });
      return this.defineValidation('onlyIfChecked', function(input, data) {
        return _this._alwaysValidIf(!document.getElementById(data.onlyIfChecked).checked);
      });
    };

    FormValidator.prototype._performRangeValidation = function(length, min, max) {
      var _i, _results;

      if (max && min && __indexOf.call((function() {
        _results = [];
        for (var _i = min; min <= max ? _i <= max : _i >= max; min <= max ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this), length) < 0) {
        return this.errors.add("Value most be at least " + min + " and maximum " + max + " characters long");
      } else if (min && length < min) {
        return this.errors.add("Value most be at least " + min);
      } else if (max && length > max) {
        return this.errors.add("Value can't be longer than " + max);
      }
    };

    FormValidator.prototype._alwaysValidIf = function(condition) {
      if (condition) {
        return this.errors.alwaysReturn([]);
      }
    };

    FormValidator.prototype._generateValidations = function(string) {
      return this.parser.parse(string);
    };

    return FormValidator;

  })();

}).call(this);
