// Generated by CoffeeScript 1.6.2
(function() {
  var toSentence,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
  };

  toSentence = function(array) {
    var lastWordConnector, sentence, twoWordsConnector, wordsConnector;

    wordsConnector = ", ";
    twoWordsConnector = " and ";
    lastWordConnector = ", and ";
    sentence = void 0;
    switch (array.length) {
      case 0:
        sentence = "";
        break;
      case 1:
        sentence = array[0];
        break;
      case 2:
        sentence = array[0] + twoWordsConnector + array[1];
        break;
      default:
        sentence = array.slice(0, -1).join(wordsConnector) + lastWordConnector + array[array.length - 1];
    }
    return sentence;
  };

  this.FormValidator = (function() {
    function FormValidator() {
      var key, parser, regexes, _i, _len, _ref;

      regexes = {};
      _ref = Object.keys(this._validations);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        regexes[key] = this._validations[key].regex;
      }
      parser = new Parser(regexes);
      parser.addDefaultValue('required', true);
      parser.addDefaultValue('allowEmpty', true);
      this.parser = parser;
    }

    FormValidator.prototype.validateInput = function(input) {
      var checked, validationResults, validations, value;

      this._errorMessages = [];
      value = input.value;
      validations = this._generateValidations(input.dataset.validation);
      validationResults = [];
      if (validations.format) {
        validationResults.push(this._validateFormat(value, validations.format));
      }
      if (validations.length) {
        validationResults.push(this._validateLength(value, validations.length));
      }
      if (validations.wordCount) {
        validationResults.push(this._validateWordCount(value, validations.wordCount));
      }
      if (validations.required && value === '') {
        this._errorMessages.push(this._validations.required.errorMessage);
        validationResults.push(false);
      }
      if (validations.allowEmpty && value === '') {
        this._errorMessages = [];
        validationResults = [true];
      }
      if (validations.dependsOn) {
        checked = document.getElementById(validations.dependsOn).checked;
        if (!checked) {
          this._errorMessages = [];
          validationResults = [true];
        }
      }
      this._setErrorMessage(input, this._errorMessages);
      if (__indexOf.call(validationResults, false) >= 0) {
        return false;
      } else {
        return true;
      }
    };

    FormValidator.prototype.defineCustomValidation = function(name, regex, errorMessage) {
      if (errorMessage == null) {
        errorMessage = this._validations.customValidations.defaultErrorMessage;
      }
      this._validations[name] = {};
      this._validations[name].regex = regex;
      this._validations[name].errorMessage = errorMessage;
      return this.parser.addDefaultValue(name, regex);
    };

    FormValidator.prototype.validateForm = function(form) {
      var input, validationResults, _i, _len, _ref;

      validationResults = [];
      _ref = form.querySelectorAll('[data-validation]');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        input = _ref[_i];
        validationResults.push(this.validateInput(input));
      }
      if (__indexOf.call(validationResults, false) >= 0) {
        return false;
      } else {
        return true;
      }
    };

    FormValidator.prototype._validations = {
      email: {
        regex: '.+@.+\\..+',
        errorMessage: 'Email is invalid'
      },
      tel: {
        regex: '\\d{8}',
        errorMessage: 'Telephone number is invalid'
      },
      length: {
        errorMessage: function(min, max) {
          if (max && min) {
            return "Value most be at least " + min + " and maximum " + max + " characters long";
          } else if (min) {
            return "Value most be at least " + min;
          } else if (max) {
            return "Value can't be longer than " + max;
          }
        }
      },
      wordCount: {
        errorMessage: function(min, max) {
          if (max && min) {
            return "Can't contain less than " + min + " or more than " + max + " words";
          } else if (min) {
            return "Can't contain less than " + min + " words";
          } else if (max) {
            return "Can't contain more than " + max + " words";
          }
        }
      },
      required: {
        errorMessage: "Can't be blank"
      },
      customValidations: {
        defaultErrorMessage: "Field is invalid"
      }
    };

    FormValidator.prototype._errorMessages = [];

    FormValidator.prototype._setErrorMessage = function(input, messages) {
      var fullMessage;

      this._resetErrorMessage(input);
      if (input.dataset.errorMessage) {
        messages = [input.dataset.errorMessage];
      }
      fullMessage = toSentence(messages).toLowerCase().capitalize();
      if (fullMessage === '') {
        return input.removeAttribute('data-error-message');
      } else {
        return input.setAttribute('data-error-message', fullMessage);
      }
    };

    FormValidator.prototype._resetErrorMessage = function(input) {
      return input.setAttribute('data-error-message', '');
    };

    FormValidator.prototype._generateValidations = function(string) {
      return this.parser.parse(string);
    };

    FormValidator.prototype._validateFormat = function(value, format) {
      var validationResults,
        _this = this;

      if (format == null) {
        format = {};
      }
      validationResults = [];
      Object.keys(format).forEach(function(key) {
        var regex, valid;

        regex = new RegExp(format[key]);
        valid = regex.test(value);
        if (!valid) {
          _this._errorMessages.push(_this._validations[key].errorMessage);
        }
        return validationResults.push(valid);
      });
      if (__indexOf.call(validationResults, false) >= 0) {
        return false;
      } else {
        return true;
      }
    };

    FormValidator.prototype._validateLength = function(value, lengths) {
      var max, min, valid;

      if (lengths == null) {
        lengths = {};
      }
      max = lengths.max;
      min = lengths.min;
      valid = this._isLengthWithinRange(value.length, min, max);
      if (!valid) {
        this._errorMessages.push(this._validations.length.errorMessage(min, max));
      }
      return valid;
    };

    FormValidator.prototype._validateWordCount = function(value, lengths) {
      var length, max, min, valid;

      if (lengths == null) {
        lengths = {};
      }
      max = lengths.max;
      min = lengths.min;
      length = value === '' ? length = 0 : value.split(/[ ]+/).length;
      valid = this._isLengthWithinRange(length, min, max);
      if (value === '' && !max) {
        valid = false;
      }
      if (!valid) {
        this._errorMessages.push(this._validations.wordCount.errorMessage(min, max));
      }
      return valid;
    };

    FormValidator.prototype._isLengthWithinRange = function(length, min, max) {
      var valid, _i, _results;

      if (max && min) {
        valid = __indexOf.call((function() {
          _results = [];
          for (var _i = min; min <= max ? _i <= max : _i >= max; min <= max ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this), length) >= 0;
      } else if (min) {
        valid = length >= min;
      } else if (max) {
        valid = length <= max;
      }
      return valid;
    };

    return FormValidator;

  })();

}).call(this);

/*
//@ sourceMappingURL=validator.map
*/
